{
	"4": {
		"preview": "[DEVOCEAN 스쿨] RN(React Native) 스터디 3주차",
		"logo": "https://static.codenary.co.kr/company-logo/375.png",
		"info": "안녕하세요 Teus입니다.올해부터 DEVOCEAN을 통해서 스터디를 진행하고 있습니다!제가 준비한 주제는 React를 활용해서 크로스플랫폼을 플랫폼 어플리캐이션을 만드는 React Native입니다!이번주는 3주차에 진행한 스터디 내용을 다루는 포스팅 입니다!0. 스터디 운영이번 주 역시 3개의 조로 나누고, 각 조별로 6~7장(다이어리 관리 앱 만들기)내용을 실습 하였습니다.(근데, 저같은 경우 실습시간동안 에러 하나에 30분을 소비하느라, 제대로 실습도 못하고 씌익씌익 왜안돼! 했던건 함정....)이번주는 기존에 배웠던 내용 + Navigation + ContextAPI를 사용해서 Component간 전역변수 관리에 대한 내용이 주를 이룹니다.1. NavigationReact를 기존에 사용해보신 분들은 아시겠지만, Component간 전환을 위해서 Navigation을 자주 이용합니다.React Native같은 경우 react-navigation을 이용하며 여기에 추가적으로 스택네비게이터, 드로어 네비게이터, 상단탭, 하단탭 네비게이터 등을 지원합니다.이때 어플리캐이션에서 자주 사용되는 하단 탭 네비게이터 예제를 보도록 하겠습니다.import React from 'react' ; import { NavigationContainer } from '@react-navigation/native' ; import { createBottomTabNavigator } from '@react-navigation/bottom-tabs' ; import { Text } from 'react-native' ; import { SafeAreaView } from 'react-native-safe-area-context' ; const Tab = createBottomTabNavigator ( ) ; function HomeScreen ( ) { return < Text > Home < / Text > ; } function SearchScreen ( ) { return < Text > Search < / Text > ; } function NotificationScreen ( ) { return < Text > Notification < / Text > ; } function MessageScreen ( ) { return < Text > Message < / Text > ; } function App ( ) { return ( < NavigationContainer > < Tab . Navigator initialRouteName = \"Home\" > < Tab . Screen name = \"Home\" component = { HomeScreen } / > < Tab . Screen name = \"Search\" component = { SearchScreen } / > < Tab . Screen name = \"Notification\" component = { NotificationScreen } / > < Tab . Screen name = \"Messa",
		"date": "5/4/2023"
	},
	"5": {
		"preview": "Memory 리소스 최적화하기 (VPA 및 Kubecost 추천로직 분석)",
		"logo": "https://static.codenary.co.kr/company-logo/375.png",
		"info": "Kubernetes 의 Node 개수는 Pod가 요청하는 CPU, Memory 의 크기에 따라 결정됩니다.Pod가 많은 CPU, Memory 를 요청할 수록 많은 불필요하게 많은 Node가 필요하며, 너무 적을 경우 안정적인 서비스 운영이 어렵습니다.이번 글에서는 Pod의 리소스 요청값(=requests) 를 최적화 하는 방법에 대해서 소개하려고 합니다.Requests와 LimitsKubernetes에 배포될 Pod 를 정의할때 아래와 같은 requests 와 limits 값을 정해야 합니다.spec.containers[].resources.requests.cpuspec.containers[].resources.requests.memoryspec.containers[].resources.limits.cpuspec.containers[].resources.limits.memoryrequests 는, Pod가 Node에 스케줄링될 때 필요한 공간 입니다.Node에 requests 만큼의 CPU, Memory 가 남아있을 경우 Pod가 스케줄링되며, 만일 부족하다면 다른 Node에 스케줄링되거나,Cluster Autoscaler 등이 구성되어 있다면 새로운 Node가 생성되고 Pod가 스케줄링 됩니다.가능한 Node가 없다면 Pending 상태로 대기합니다.limits 은 Pod가 실제 사용할수 있는 최대 리소스입니다.requests.cpu=100m, limits.cpu=200m 이라면 Pod는 100m의 여유가 있는 Node에 스케줄링 되지만, 실제 동작시에는 최대 200m 까지 사용할 수 있습니다.따라서 특정 Node의 모든 Pod 의 sum(limits) 값이 Node의 실제 CPU 보다 클 수 있습니다.따라서 다수의 Pod가 동시에 requests 이상의 CPU를 사용할 경우 Node의 CPU가 부족해질수 있고, throttling 으로 인한 전체적인 성능저하가 발생할수 있습니다.만일 Memory가 부족하다면 OOMKilled가 (Out of Memory) 발생할수 있습니다.Requests는 비용이중 비용(=Node수)과 직결되는건 requests 값 입니다. requests 가 너무 클 경우 불필요한 Node로 인한 비용 낭비가 발생할 수 있습니다.반대로 너무 적을 경우 하나의 Node에 너무 많은 Pod가 스케줄링되어 throttling 및 OOMKilled가 빈번하게 발생할 수 있습니다.그렇다면 어떻게 적절한 Requests 값을 찾을수 있을까요?실사용량 기반의 Requests 최적화실제 Pod가 사용하는 리소스 사용량을 측정하고 이를 기반으로 Requests 값을 정하는 것입니다. (사실 당연한 얘기)VPA (Vertical Pod Autoscaler) 와 Kubecost 는 이러한 방식의 Recommender 를 가지고 있습니다.전체적인 Architecture는 거의 유사한데, metric server 로부터 Pod의 실사용량을 수집하고, 이를 기반으로 requests 값을 추천하는 방식입니다.Requests 를 어떻게 계산할",
		"date": "5/4/2023"
	},
	"6": {
		"preview": "내가 만든 워드클라우드 : 성능개선을 위한 여정 (Web Worker)",
		"logo": "https://static.codenary.co.kr/company-logo/1311.png",
		"info": "안녕하세요. 아이지에이웍스 MI 개발실에서 프론트엔드 개발을 맡고 있는 예리엘입니다.🔍워드클라우드?워드클라우드는 데이터를 시각적으로 보여줌으로써 키워드와 개념을 직관적으로 파악할 수 있게 해줄 수 있는 기법입니다. 가중치가 크거나 빈도가 높은 단어는 크게 표현해 한 눈에 들어 올수있게 하는 대표적인 기법이 있습니다.이러한 특징으로 컴포넌트를 만들 때 고려해야 하는 부분들이 많고 복잡할 수 있습니다. 하지만 직접 만들어보면 배울 점이 많은 과제라고 생각하여 직접 만들어 보았습니다.🧐 첫 워드클라우드 아쉬운 완성초기에 구현했던 워드클라우드는 BFS로 전체 캔버스를 탐색하고 DFS로 글자크기만큼 비었는지 확인 후 단어를 놓았습니다. 그러고 나서 완전 탐색으로 다시 전체 canvas 빈자리를 확안하고 단어를 놓는 로직으로 구현하였습니다.보라색 색깔 글자를 보게 되면 3가지의 알고리즘이 사용하였습니다. 이중배열, while, 재귀까지 복잡성을 높이는 여러 요소가 포함되어 있습니다.그 결과 코드의 복잡성과 연산 시간이 늘어남과 동시에 만족스럽지 않은 결과물을 얻었습니다. 🥲🥲글자도 겹치고 답답해 보이는 첫 워드클라우드...구체적인 문제점과 개선방안다시 한번 코드를 확인하면서 로직 외에도 다양한 관점에서 코드를 분석해 봤습니다.문제점1. 연산시 필요하지 않은 this 참조 array 2. 확장이 어려운 구조 3. 연산 위치의 정확성 4. 싱글스레드(메인스레드) 연산으로 스레드를 점유하는 상태 5. 재귀로 인해 연산의 사이즈가 커지면 `Maximum call stack size` 발생개선해보자~~!➊. 연산시 필요하지 않은 this 참조 array➡ this 참조는 최대한 지양하고 순수함수로 구성.private readonly visitedBuffer = Array . from ( Array ( this . originalCanvasWidth ) , ( ) => new Array ( this . originalCanvasHeight ) . fill ( 0 ) ) ;visitedBuffer는 캔버스 크기만큼의 이중 배열이 필요할 때마다 사용하기 위해 this 참조 변수입니다.대체로 방문을 확인하는 용도로 사용하였습니다.const visited = new Set ( ) ; ... while ( queue ) { visited . has ( ) ; ... visited . add ( ) ; }필요할 때마다 배열을 만드는 것이 아니라 순수 함수로 외부 상태에 의존하지 않는 방향으로 코드를 변경하였습니다.전에는 이중 배열로 방문을 확인했다면 해당 함수의 Set 자료구조를 사용하여 연산을 진행하는 함수 안에서만 사용되게 하였습니다.❷. 확장이 어려운 구조➡ 옵션 정리 (width, height, minFontSize, maxFontSize ...)< WordCloud words = { WordCloudValues } size = { 5 } width = { 50 } height = { 50 } />기본으로 width, height, 단어리스트, 크기 등 사용자는",
		"date": "5/4/2023"
	},
	"7": {
		"preview": "EKS Jam For App Modernization 워크샵 1등의 추억",
		"logo": "https://static.codenary.co.kr/company-logo/4248.png",
		"info": "EKS Jam For App Modernization 워크샵에서 1등을 하다!안녕하세요. 무신사 테크의 SRE팀 안다혜, 최성우입니다.저희는 지난 4월 11일~12일에AWS와 LG CNS가 함께 주최한 EKS Jam fopr App Modernization(이하 AM핸즈온)에 참가했는데요. 이 행사에서 ‘우승’을 했다는 좋은 소식을 전하기 위해, 글을 씁니다.어떤 계기로 이 행사에 참여했고, 어떻게 우승할 수 있었는지 그 생생한 이야기를 저희가 들려드릴게요.AM 핸즈온이란?성우 : AM 핸즈온 이틀간 진행되었는데요. 첫날 워크숍을 통해 Security, Autoscaling, Observability, Network, Automation 의 5가지의 항목에 대해서 App Modernization을 적용할 수 있는 방법을 배우고, 둘째날에 5가지 각 항목에 대해서 실제 DevOps/SRE들이 EKS를 도입/운영하며 마주하게 되는 문제들을 해결하고 점수를 얻는 *Jam을 진행했습니다.(*JAM이란 즉흥합주에서 유래된 단어로, 현장에서 주어지는 주제로 한정된 시간 안에 즉석에서 개발하는 세션을 의미합니다.)다혜 : 무신사의 여러 서비스는 컨테이너 환경에서 구동되고 있는데요. 여러 컨테이너를 효율적으로 관리하는 관리형 서비스 중 하나가 EKS(Elastic Kubernetes Service)입니다. EKS에서 App Modernization이란 클라우드 환경에서 애플리케이션을 더 효율적이고 안정적으로 운영하는 것을 의미합니다. 예를 들어, 컨테이너 환경과 MSA(Micro Service Architecture)를 사용함으로써 서비스마다 독립성을 높여 스케일 확장을 효율적으로 하고, 장애가 일어나더라도 서비스에 미치는 영향을 최소화할 수 있습니다. 따라서 이 워크숍은 무신사의 여러 서비스를 더 효율적으로 관리하고 안정적으로 운영하는 기술을 배울 수 있을 좋은 기회였죠.AM핸즈온에 참여하게 된 계기다혜 : DevOps/인프라 관련 정보 공유 카톡방에 이 AM 핸즈온에 대한 글이 올라온 걸 발견했는데, ‘상금 100만 원’이 눈길을 끌더라구요. 바로 ‘사이트 신뢰성 엔지니어링’이란 책으로 저희 팀 성우 님, 그리고 다른 회사에서 DevOps로 일하는 지인 두 분이 있는 스터디 카톡방에 공유했습니다. 이 DevOps 지인 두 분과 저는 2022 AWS Community Day의 GameDay에서 1등을 한 전적이 있었습니다. 이미 한번 대회에서 합을 맞춰 보았기에 이 두 분의 실력은 익히 알고 있었고, 성우님과도 6개월 이상 같이 일을 하며 성우님의 능력도 역시 알고 있었습니다. 그렇게 팀을 먼저 꾸렸습니다.상금헌터를 다짐했던 당시의 카톡 대화다혜: 이후에, 저희 팀 리더이신 호진 님께도 링크를 보여드리며 “요런 게 있는데… 상금을 타러… 다녀오고 싶어요..” 라고 말씀드렸는데요, 양일 모두 교육으로 처리할 수 있게 도와주셔서 참여할 수 있었습니다.평소 SRE팀의 일원으로 업무를 하면서 ‘EKS, 네트워크, 보안 등과 관련된 기술들을 깊게 알아야 하는",
		"date": "5/3/2023"
	},
	"8": {
		"preview": "달리는 인증 서비스의 NoSQL을 바꾸자. - 전략편",
		"logo": "https://static.codenary.co.kr/company-logo/373.png",
		"info": "안녕하세요. Seller & SD Engineering 팀 박명훈입니다. 최근 개발자로서 직접 기안한 프로젝트를 완료했습니다. 팀에서는 Couchbase를 통해 인증 서비스의 데이터를 제공하고 있었는데, 낮은 사용성 이슈와 비즈니스 정책, 서비스 관리의 여러 이유로 인해 불편함이 많았고, 이로 인해 기획자들이 업무를 진행할 때 성능 이슈로 인해 거의 사용이 불가능할 정도로 문제가 많았습니다. 대표적인 예시로 검색을 하면 5분씩 걸렸습니다. Couchbase는 MongoDB와 같이 Key-Document 구조를 가진 NoSQL 입니다. 이번 기회에 개선을 진행하며 기존의 문제를 해결하고, 성능적으로나 서비스적으로 아쉬웠던 부분을 개선했습니다. 그 과정과 결과에 대해서는 내용이 많아 크게 전략편과 실전 편으로 나눠서 서술할려고 합니다. 달리는 인증 서비스의 NoSQL을 바꾸자. - 전략편달리는 인증 서비스의 NoSQL을 바꾸자. - 실전편 간략하게 서비스를 소개하면 저희 팀에서는 Couchbase를 통해, 외부에 제공하는 사내 API의 Gateway 인증 서비스를 관리하고 개발하고 있습니다. 이 서비스를 통해 인증된 외부에서 개발자들의 지마켓이나 옥션 등의 상품, 주문, 배송, 클레임, 정산 등의 API를 사용할 수 있게 됩니다. 즉, API 사용자가 인가된 사용자인지를 확인해 주는 인증 서버입니다. 인증 서비스의 간략한 구조 기존 서비스의 문제.기존의 서비스에서는 여러 문제가 있었습니다. 특히 가장 큰 문제는 사용자 입장에서가 아닌 관리자 측면에서는 설계가 부족했던 부분이었습니다. 과거에서는 문제가 안되었을 수 있으나, 데이터가 많아지면서 점점 더 드러난 문제입니다. 문제 1. 관리자 입장에서 최악의 구조관리자 입장에서 특정 기준의 데이터를 조회해야 할 때 모든 document를 뒤져봐야 하는 단점이 있었습니다. couchbase에서도 indexing 을 지원하나, 저희 구조에서는 임시방편이라고 느끼기도 했고, 뒤에 나올 여러 가지 이유로 인해 비효율적이라고 판단했습니다. document 접근 구조의 문제 해당 서비스는 사용자 입장에서 설게 된 서비스이고, 관리자 측면에 미흡하게 구성된 부분이 있습니다. 각 document는 판매자 id를 기반으로 돌아갑니다. 그러나 관리자가 사용을 할 때는 아이디 값보다는 상태 값을 기반으로 id를 찾는 경우가 더 많습니다. 대표적인 예시로 특정 계정들이 API를 사용할 수 있도록 승인해 주는 기능을 관리자에서 수행할 때, 성능이슈가 크게 발생했습니다. 따라서 이를 고려하면 다음과 같은 성능 차이가 있게 됩니다. 유저 기준 : T(n) = O(1)관리자 기준 : T(n) = O(n)그리고 특정 document의 값 자체를 히스토리로 저장함으로써 불필요한 공간을 차지하고 있었습니다. 관리자 측면에서의 설계 이슈와 불필요한 document의 데이터 적재로 인해 날이 가면 갈수록 큰 성능 저하가 발생했습니다. 문제 2. Couchbase에 대한 인프라 이슈성능 이슈와 함께 이 작업을 진행하게 된 가장 큰 이슈",
		"date": "5/3/2023"
	},
	"9": {
		"preview": "Spring Camp 2023 @을지로 SKT타워 참관 후기",
		"logo": "https://static.codenary.co.kr/company-logo/375.png",
		"info": "안녕하세요. 지난 4/22 토요일, DEVOCEAN에서 초대권을 받아 을지로 SKT타워에서 진행된 Spring Camp 2023 행사에 다녀왔습니다.Spring Camp 2023 에서 진행한 세션에 대한 간략한 소개와 후기를 적어보겠습니다.행사는 오전 11시에 접수를 시작하여, 12시부터 18시까지 총 7개의 세션이 진행되었습니다.세션 영상은 가까운 시일 내에 유튜브 채널로 업로드된다고 하니 오프라인에 참여하지 못하신 분들도 아래 내용을 참고하셔서 필요한 내용은 들어보시길 추천드립니다.또한, 일부 발표 자료들은 이미 KSUG 페이스북 그룹에 업로드되어 있으니 관심 있는 분들은 참고하시면 좋을 거 같습니다..세션1. 어느 #월급쟁이개발자 의 스프링 부트 따라잡기 Ver.3첫 번째 세션을 한 문장으로 요약하자면, \"Spring 6 와 Spring Boot 3 는 이전 버전과 어떤 게 다른가?\" 입니다.이 세션을 통해 Java, Jakarta EE, Spring, Spring Boot 각각의 최신 버전에 포함된 기능들이 어떤 것들이 있는지 빠르게 훑어볼 수 있습니다.무엇이 달라졌는지, 왜 달라졌는지 한눈에 보고자 하시는 분들이 계시다면 아래 세션을 보시는 걸 추천합니다.또한, 앞으로 직접 변경 내용을 확인하고자 하신다면, 발표 중간에 언급된 것처럼 Spring Blog 의 Release Note 또는 Spring 프로젝트의 Github Wiki를 통해 직접 내용을 확인할 수 있습니다.세션2. 글로벌 서비스를 위한 Timezone/DST두 번째 세션을 한 문장으로 요약하자면, \"Summer Time 에 대처하는 Java\" 입니다.다양한 Timezone 을 대상으로 하는 서비스가 아니라면 당장은 무관할 수 있지만, 글로벌 서비스를 지향하는 개발자라면 한 번쯤 정리해 볼 법한 주제라고 생각합니다.시간 관련 용어, Java의 시간 Package 및 Class, 그리고 실무에서의 적용에 관한 내용을 확인할 수 있습니다.다만, 이 주제는 단순히 개발자의 입장에서만 이해하기보다 서비스를 어떻게 기획하고 책임을 나눌지에 대해서도 함께 고민해볼 필요가 있습니다.세션 3&4. 대규모 엔터프라이즈 시스템 개선 경험기세 번째와 네 번째 세션은 같은 경험에 대해서 각각 시니어와 주니어 분이 발표를 진행했습니다. 제목 그대로 대규모 엔터프라이즈 시스템을 개선할 때 설계 전략과 구체적인 내용에 대해 들을 수 있습니다.Ports&Adapters Architecture, Event-Driven Architecture, Domain Driven Development를 기반으로 하여 기존 시스템을 점진적으로 옮겨가는 과정에서 마주한 고민들을 생생하게 들을 수 있었습니다.발표자 분께서 말씀하셨듯이 1부는 전체적인 방향성을 고민하는 분(보통 시니어)이, 2부는 코드단 내용이 궁금한 분이 듣는 걸 추천합니다.세션5. 실무에서 적용하는 테스트 코드 작성 방법과 노하우다섯 번째 세션을 한 문장으로 요약하자면, \"좋은 테스트를 위한 고민의 과정\" 입니다.테스트 코드를 좀 더 재사용 가능",
		"date": "5/3/2023"
	},
	"10": {
		"preview": "4월 백엔드 개발 리뷰",
		"logo": "https://static.codenary.co.kr/company-logo/573.png",
		"info": "킵그로우 개발 챕터 Brown 입니다.4월의 백엔드 개발 리뷰에서는 잘못 설계해서 힘들었던 경험을 공유하고 기능 개발 전, 설계 시 고려 사항에 대해 논의하였고 TDD 방법론과 관련한 세부 주제들을 바탕으로 리뷰를 진행하였습니다.잘못 설계해서 힘들었던 경험 공유설계가 끝난 후(위) / 설계를 하는 중(아래)잘못된 설계로 힘들었던 경우에 대하여 다양한 경험들을 공유하였습니다.개발해야하는 기능을 서로 다르게 이해하고 설계를 하게된 경우기능을 개발하게 된 의도를 제대로 파악하지 못한 경우특정 도메인에 대한 이해나, 문서 등에 대한 서치가 부족한 채 설계한 경우잘못된 설계로 기능 개발 자체의 난이도가 높아지는 경우다른 기능의 설계를 차용 하였으나, 현재 도메인에는 맞지 않는 경우기능 개발 전, 설계 시 고려 사항에 대한 공유앞서 잘못된 설계로 힘들었던 들을 바탕으로 설계 시 고려 사항에 대한 내용을 논의하였습니다.보통 잘못 설계한 경우, 개발 자체가 어려워지고 이를 본인도 알고 있다. 개발 일정에 맞추려, 수정 없이 두게되면 결국 레거시 코드가 되기 때문에 개발 자체가 쉽게 풀리지 않는 경우, 빠르게 다른 사람에게 도움을 받거나 다시 설계한다.단순한 기능 추가가 아닌 다른 방법이 있는지에 대해서 고민한다. 이전에 만들어진 기능을 활용할 수 있는지 확인하고 비개발적인 방향으로도 이를 해결할 수 있는지에 대해 고민한다.도메인에 대한 지식과 기술에 대한 이해를 가지고 설계를 시작한다. 얕은 지식과 잘못된 이해를 바탕으로 만들어진 설계는 구현 단계에서 불가능한 부분이 있음을 깨닫게 된다.해당 기능이 왜 만들어지게 되었는지, 의도에 대해 파악 해야한다.기능이 확장될 수 있다는 생각을 가지고 설계한다. 절대 라는 것은 없기 때문에 예상 할 수 있는 추가 기능들도 설계 시 같이 고려한다.TDD 방법론에 대한 논의실무에서 TDD를 얼마만큼 활용하고 있는지, TDD의 장단점은 무엇인지, TDD는 필수 인지 등, 각 개발자 분들이 생각하시고 적용하고 계신 TDD에 대해 자유롭게 이야기를 나누었습니다.통합 테스트가 성공하는 경우Matthew께서 정리해주신 TDD를 사용하는 이유, TDD의 장단점에 대한 내용은 아래와 같습니다.아래 내용을 바탕으로 TDD가 가지는 장점과 이를 개발 일정에 맞춰 활용하기 위한 숙련도가 필요함에 대해 이야기를 나누었고, 적용하는 범위와 어떤 식으로 구현하는지에 대해 공유하였습니다.TDD를 사용하는 이유일반적인 개발방식일반적인 개발방식에서 버그가 발생한다면 원인을 찾기 위해 디버깅과 많은 코드를 탐색해야 한다. 최악의 경우 개발한 시간보다 버그를 찾는 시간이 길어지거나 설계를 뒤집어야 하는 상황이 발생할 수 있다.TDD 개발방식TDD 개발방식이 일반적인 개발 방식과 다른 점은 MVP(Minimum Viable Product) 단위로 테스트가 성공할 때마다 점진적으로 기능을 확장해 나감과 동시에 신뢰성을 높이는 방식이다.TDD의 장점개발자에게 잘 동작하는 기능을 수정하는 것은 심리적 불안감을 주기 때문에 꺼려지는 작업이다. 하지만 기능의",
		"date": "5/2/2023"
	}
}